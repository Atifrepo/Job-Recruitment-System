{"ast":null,"code":"/*!\n * Copyright (c) 2015 Chris O'Hara <cohara87@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n(function (name, definition) {\n  if (typeof exports !== 'undefined' && typeof module !== 'undefined') {\n    module.exports = definition();\n  } else if (typeof define === 'function' && typeof define.amd === 'object') {\n    define(definition);\n  } else {\n    this[name] = definition();\n  }\n})('validator', function (validator) {\n  'use strict';\n\n  validator = {\n    version: '3.43.0'\n  };\n  var emailUser = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e])|(\\\\[\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f])))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))$/i;\n  var emailUserUtf8 = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))$/i;\n  var displayName = /^(?:[a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\.]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(?:[a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~\\.]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|\\s)*<(.+)>$/i;\n  var creditCard = /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/;\n  var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;\n  var isbn10Maybe = /^(?:[0-9]{9}X|[0-9]{10})$/,\n      isbn13Maybe = /^(?:[0-9]{13})$/;\n  var ipv4Maybe = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/,\n      ipv6Block = /^[0-9A-F]{1,4}$/i;\n  var uuid = {\n    '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,\n    '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n    '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i\n  };\n  var alpha = /^[A-Z]+$/i,\n      alphanumeric = /^[0-9A-Z]+$/i,\n      numeric = /^[-+]?[0-9]+$/,\n      int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/,\n      float = /^(?:[-+]?(?:[0-9]+))?(?:\\.[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$/,\n      hexadecimal = /^[0-9A-F]+$/i,\n      decimal = /^[-+]?[0-9]*(\\.[0-9]+)?$/,\n      hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{6})$/i;\n  var ascii = /^[\\x00-\\x7F]+$/,\n      multibyte = /[^\\x00-\\x7F]/,\n      fullWidth = /[^\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/,\n      halfWidth = /[\\u0020-\\u007E\\uFF61-\\uFF9F\\uFFA0-\\uFFDC\\uFFE8-\\uFFEE0-9a-zA-Z]/;\n  var surrogatePair = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/;\n  var base64 = /^(?:[A-Z0-9+\\/]{4})*(?:[A-Z0-9+\\/]{2}==|[A-Z0-9+\\/]{3}=|[A-Z0-9+\\/]{4})$/i;\n  var phones = {\n    'zh-CN': /^(\\+?0?86\\-?)?1[345789]\\d{9}$/,\n    'en-ZA': /^(\\+?27|0)\\d{9}$/,\n    'en-AU': /^(\\+?61|0)4\\d{8}$/,\n    'en-HK': /^(\\+?852\\-?)?[569]\\d{3}\\-?\\d{4}$/,\n    'fr-FR': /^(\\+?33|0)[67]\\d{8}$/,\n    'pt-PT': /^(\\+351)?9[1236]\\d{7}$/,\n    'el-GR': /^(\\+30)?((2\\d{9})|(69\\d{8}))$/,\n    'en-GB': /^(\\+?44|0)7\\d{9}$/,\n    'en-US': /^(\\+?1)?[2-9]\\d{2}[2-9](?!11)\\d{6}$/,\n    'en-ZM': /^(\\+26)?09[567]\\d{7}$/,\n    'ru-RU': /^(\\+?7|8)?9\\d{9}$/\n  };\n\n  validator.extend = function (name, fn) {\n    validator[name] = function () {\n      var args = Array.prototype.slice.call(arguments);\n      args[0] = validator.toString(args[0]);\n      return fn.apply(validator, args);\n    };\n  }; //Right before exporting the validator object, pass each of the builtins\n  //through extend() so that their first argument is coerced to a string\n\n\n  validator.init = function () {\n    for (var name in validator) {\n      if (typeof validator[name] !== 'function' || name === 'toString' || name === 'toDate' || name === 'extend' || name === 'init') {\n        continue;\n      }\n\n      validator.extend(name, validator[name]);\n    }\n  };\n\n  validator.toString = function (input) {\n    if (typeof input === 'object' && input !== null && input.toString) {\n      input = input.toString();\n    } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {\n      input = '';\n    } else if (typeof input !== 'string') {\n      input += '';\n    }\n\n    return input;\n  };\n\n  validator.toDate = function (date) {\n    if (Object.prototype.toString.call(date) === '[object Date]') {\n      return date;\n    }\n\n    date = Date.parse(date);\n    return !isNaN(date) ? new Date(date) : null;\n  };\n\n  validator.toFloat = function (str) {\n    return parseFloat(str);\n  };\n\n  validator.toInt = function (str, radix) {\n    return parseInt(str, radix || 10);\n  };\n\n  validator.toBoolean = function (str, strict) {\n    if (strict) {\n      return str === '1' || str === 'true';\n    }\n\n    return str !== '0' && str !== 'false' && str !== '';\n  };\n\n  validator.equals = function (str, comparison) {\n    return str === validator.toString(comparison);\n  };\n\n  validator.contains = function (str, elem) {\n    return str.indexOf(validator.toString(elem)) >= 0;\n  };\n\n  validator.matches = function (str, pattern, modifiers) {\n    if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {\n      pattern = new RegExp(pattern, modifiers);\n    }\n\n    return pattern.test(str);\n  };\n\n  var default_email_options = {\n    allow_display_name: false,\n    allow_utf8_local_part: true,\n    require_tld: true\n  };\n\n  validator.isEmail = function (str, options) {\n    options = merge(options, default_email_options);\n\n    if (options.allow_display_name) {\n      var display_email = str.match(displayName);\n\n      if (display_email) {\n        str = display_email[1];\n      }\n    } else if (/\\s/.test(str)) {\n      return false;\n    }\n\n    var parts = str.split('@'),\n        domain = parts.pop(),\n        user = parts.join('@');\n    var lower_domain = domain.toLowerCase();\n\n    if (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com') {\n      user = user.replace(/\\./g, '').toLowerCase();\n    }\n\n    if (!validator.isFQDN(domain, {\n      require_tld: options.require_tld\n    })) {\n      return false;\n    }\n\n    return options.allow_utf8_local_part ? emailUserUtf8.test(user) : emailUser.test(user);\n  };\n\n  var default_url_options = {\n    protocols: ['http', 'https', 'ftp'],\n    require_tld: true,\n    require_protocol: false,\n    require_valid_protocol: true,\n    allow_underscores: false,\n    allow_trailing_dot: false,\n    allow_protocol_relative_urls: false\n  };\n\n  validator.isURL = function (url, options) {\n    if (!url || url.length >= 2083 || /\\s/.test(url)) {\n      return false;\n    }\n\n    if (url.indexOf('mailto:') === 0) {\n      return false;\n    }\n\n    options = merge(options, default_url_options);\n    var protocol, auth, host, hostname, port, port_str, split;\n    split = url.split('://');\n\n    if (split.length > 1) {\n      protocol = split.shift();\n\n      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {\n        return false;\n      }\n    } else if (options.require_protocol) {\n      return false;\n    } else if (options.allow_protocol_relative_urls && url.substr(0, 2) === '//') {\n      split[0] = url.substr(2);\n    }\n\n    url = split.join('://');\n    split = url.split('#');\n    url = split.shift();\n    split = url.split('?');\n    url = split.shift();\n    split = url.split('/');\n    url = split.shift();\n    split = url.split('@');\n\n    if (split.length > 1) {\n      auth = split.shift();\n\n      if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {\n        return false;\n      }\n    }\n\n    hostname = split.join('@');\n    split = hostname.split(':');\n    host = split.shift();\n\n    if (split.length) {\n      port_str = split.join(':');\n      port = parseInt(port_str, 10);\n\n      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {\n        return false;\n      }\n    }\n\n    if (!validator.isIP(host) && !validator.isFQDN(host, options) && host !== 'localhost') {\n      return false;\n    }\n\n    if (options.host_whitelist && options.host_whitelist.indexOf(host) === -1) {\n      return false;\n    }\n\n    if (options.host_blacklist && options.host_blacklist.indexOf(host) !== -1) {\n      return false;\n    }\n\n    return true;\n  };\n\n  validator.isIP = function (str, version) {\n    version = validator.toString(version);\n\n    if (!version) {\n      return validator.isIP(str, 4) || validator.isIP(str, 6);\n    } else if (version === '4') {\n      if (!ipv4Maybe.test(str)) {\n        return false;\n      }\n\n      var parts = str.split('.').sort(function (a, b) {\n        return a - b;\n      });\n      return parts[3] <= 255;\n    } else if (version === '6') {\n      var blocks = str.split(':');\n      var foundOmissionBlock = false; // marker to indicate ::\n      // At least some OS accept the last 32 bits of an IPv6 address\n      // (i.e. 2 of the blocks) in IPv4 notation, and RFC 3493 says\n      // that '::ffff:a.b.c.d' is valid for IPv4-mapped IPv6 addresses,\n      // and '::a.b.c.d' is deprecated, but also valid.\n\n      var foundIPv4TransitionBlock = validator.isIP(blocks[blocks.length - 1], 4);\n      var expectedNumberOfBlocks = foundIPv4TransitionBlock ? 7 : 8;\n      if (blocks.length > expectedNumberOfBlocks) return false; // initial or final ::\n\n      if (str === '::') {\n        return true;\n      } else if (str.substr(0, 2) === '::') {\n        blocks.shift();\n        blocks.shift();\n        foundOmissionBlock = true;\n      } else if (str.substr(str.length - 2) === '::') {\n        blocks.pop();\n        blocks.pop();\n        foundOmissionBlock = true;\n      }\n\n      for (var i = 0; i < blocks.length; ++i) {\n        // test for a :: which can not be at the string start/end\n        // since those cases have been handled above\n        if (blocks[i] === '' && i > 0 && i < blocks.length - 1) {\n          if (foundOmissionBlock) return false; // multiple :: in address\n\n          foundOmissionBlock = true;\n        } else if (foundIPv4TransitionBlock && i == blocks.length - 1) {// it has been checked before that the last\n          // block is a valid IPv4 address\n        } else if (!ipv6Block.test(blocks[i])) {\n          return false;\n        }\n      }\n\n      if (foundOmissionBlock) {\n        return blocks.length >= 1;\n      } else {\n        return blocks.length === expectedNumberOfBlocks;\n      }\n    }\n\n    return false;\n  };\n\n  var default_fqdn_options = {\n    require_tld: true,\n    allow_underscores: false,\n    allow_trailing_dot: false\n  };\n\n  validator.isFQDN = function (str, options) {\n    options = merge(options, default_fqdn_options);\n    /* Remove the optional trailing dot before checking validity */\n\n    if (options.allow_trailing_dot && str[str.length - 1] === '.') {\n      str = str.substring(0, str.length - 1);\n    }\n\n    var parts = str.split('.');\n\n    if (options.require_tld) {\n      var tld = parts.pop();\n\n      if (!parts.length || !/^([a-z\\u00a1-\\uffff]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {\n        return false;\n      }\n    }\n\n    for (var part, i = 0; i < parts.length; i++) {\n      part = parts[i];\n\n      if (options.allow_underscores) {\n        if (part.indexOf('__') >= 0) {\n          return false;\n        }\n\n        part = part.replace(/_/g, '');\n      }\n\n      if (!/^[a-z\\u00a1-\\uffff0-9-]+$/i.test(part)) {\n        return false;\n      }\n\n      if (part[0] === '-' || part[part.length - 1] === '-' || part.indexOf('---') >= 0) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  validator.isBoolean = function (str) {\n    return ['true', 'false', '1', '0'].indexOf(str) >= 0;\n  };\n\n  validator.isAlpha = function (str) {\n    return alpha.test(str);\n  };\n\n  validator.isAlphanumeric = function (str) {\n    return alphanumeric.test(str);\n  };\n\n  validator.isNumeric = function (str) {\n    return numeric.test(str);\n  };\n\n  validator.isDecimal = function (str) {\n    return decimal.test(str);\n  };\n\n  validator.isHexadecimal = function (str) {\n    return hexadecimal.test(str);\n  };\n\n  validator.isHexColor = function (str) {\n    return hexcolor.test(str);\n  };\n\n  validator.isLowercase = function (str) {\n    return str === str.toLowerCase();\n  };\n\n  validator.isUppercase = function (str) {\n    return str === str.toUpperCase();\n  };\n\n  validator.isInt = function (str, options) {\n    options = options || {};\n    return int.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);\n  };\n\n  validator.isFloat = function (str, options) {\n    options = options || {};\n    return str !== '' && float.test(str) && (!options.hasOwnProperty('min') || str >= options.min) && (!options.hasOwnProperty('max') || str <= options.max);\n  };\n\n  validator.isDivisibleBy = function (str, num) {\n    return validator.toFloat(str) % validator.toInt(num) === 0;\n  };\n\n  validator.isNull = function (str) {\n    return str.length === 0;\n  };\n\n  validator.isLength = function (str, min, max) {\n    var surrogatePairs = str.match(/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g) || [];\n    var len = str.length - surrogatePairs.length;\n    return len >= min && (typeof max === 'undefined' || len <= max);\n  };\n\n  validator.isByteLength = function (str, min, max) {\n    return str.length >= min && (typeof max === 'undefined' || str.length <= max);\n  };\n\n  validator.isUUID = function (str, version) {\n    var pattern = uuid[version ? version : 'all'];\n    return pattern && pattern.test(str);\n  };\n\n  validator.isDate = function (str) {\n    return !isNaN(Date.parse(str));\n  };\n\n  validator.isAfter = function (str, date) {\n    var comparison = validator.toDate(date || new Date()),\n        original = validator.toDate(str);\n    return !!(original && comparison && original > comparison);\n  };\n\n  validator.isBefore = function (str, date) {\n    var comparison = validator.toDate(date || new Date()),\n        original = validator.toDate(str);\n    return original && comparison && original < comparison;\n  };\n\n  validator.isIn = function (str, options) {\n    var i;\n\n    if (Object.prototype.toString.call(options) === '[object Array]') {\n      var array = [];\n\n      for (i in options) {\n        array[i] = validator.toString(options[i]);\n      }\n\n      return array.indexOf(str) >= 0;\n    } else if (typeof options === 'object') {\n      return options.hasOwnProperty(str);\n    } else if (options && typeof options.indexOf === 'function') {\n      return options.indexOf(str) >= 0;\n    }\n\n    return false;\n  };\n\n  validator.isCreditCard = function (str) {\n    var sanitized = str.replace(/[^0-9]+/g, '');\n\n    if (!creditCard.test(sanitized)) {\n      return false;\n    }\n\n    var sum = 0,\n        digit,\n        tmpNum,\n        shouldDouble;\n\n    for (var i = sanitized.length - 1; i >= 0; i--) {\n      digit = sanitized.substring(i, i + 1);\n      tmpNum = parseInt(digit, 10);\n\n      if (shouldDouble) {\n        tmpNum *= 2;\n\n        if (tmpNum >= 10) {\n          sum += tmpNum % 10 + 1;\n        } else {\n          sum += tmpNum;\n        }\n      } else {\n        sum += tmpNum;\n      }\n\n      shouldDouble = !shouldDouble;\n    }\n\n    return !!(sum % 10 === 0 ? sanitized : false);\n  };\n\n  validator.isISIN = function (str) {\n    if (!isin.test(str)) {\n      return false;\n    }\n\n    var checksumStr = str.replace(/[A-Z]/g, function (character) {\n      return parseInt(character, 36);\n    });\n    var sum = 0,\n        digit,\n        tmpNum,\n        shouldDouble = true;\n\n    for (var i = checksumStr.length - 2; i >= 0; i--) {\n      digit = checksumStr.substring(i, i + 1);\n      tmpNum = parseInt(digit, 10);\n\n      if (shouldDouble) {\n        tmpNum *= 2;\n\n        if (tmpNum >= 10) {\n          sum += tmpNum + 1;\n        } else {\n          sum += tmpNum;\n        }\n      } else {\n        sum += tmpNum;\n      }\n\n      shouldDouble = !shouldDouble;\n    }\n\n    return parseInt(str.substr(str.length - 1), 10) === (10000 - sum) % 10;\n  };\n\n  validator.isISBN = function (str, version) {\n    version = validator.toString(version);\n\n    if (!version) {\n      return validator.isISBN(str, 10) || validator.isISBN(str, 13);\n    }\n\n    var sanitized = str.replace(/[\\s-]+/g, ''),\n        checksum = 0,\n        i;\n\n    if (version === '10') {\n      if (!isbn10Maybe.test(sanitized)) {\n        return false;\n      }\n\n      for (i = 0; i < 9; i++) {\n        checksum += (i + 1) * sanitized.charAt(i);\n      }\n\n      if (sanitized.charAt(9) === 'X') {\n        checksum += 10 * 10;\n      } else {\n        checksum += 10 * sanitized.charAt(9);\n      }\n\n      if (checksum % 11 === 0) {\n        return !!sanitized;\n      }\n    } else if (version === '13') {\n      if (!isbn13Maybe.test(sanitized)) {\n        return false;\n      }\n\n      var factor = [1, 3];\n\n      for (i = 0; i < 12; i++) {\n        checksum += factor[i % 2] * sanitized.charAt(i);\n      }\n\n      if (sanitized.charAt(12) - (10 - checksum % 10) % 10 === 0) {\n        return !!sanitized;\n      }\n    }\n\n    return false;\n  };\n\n  validator.isMobilePhone = function (str, locale) {\n    if (locale in phones) {\n      return phones[locale].test(str);\n    }\n\n    return false;\n  };\n\n  var default_currency_options = {\n    symbol: '$',\n    require_symbol: false,\n    allow_space_after_symbol: false,\n    symbol_after_digits: false,\n    allow_negatives: true,\n    parens_for_negatives: false,\n    negative_sign_before_digits: false,\n    negative_sign_after_digits: false,\n    allow_negative_sign_placeholder: false,\n    thousands_separator: ',',\n    decimal_separator: '.',\n    allow_space_after_digits: false\n  };\n\n  validator.isCurrency = function (str, options) {\n    options = merge(options, default_currency_options);\n    return currencyRegex(options).test(str);\n  };\n\n  validator.isJSON = function (str) {\n    try {\n      var obj = JSON.parse(str);\n      return !!obj && typeof obj === 'object';\n    } catch (e) {}\n\n    return false;\n  };\n\n  validator.isMultibyte = function (str) {\n    return multibyte.test(str);\n  };\n\n  validator.isAscii = function (str) {\n    return ascii.test(str);\n  };\n\n  validator.isFullWidth = function (str) {\n    return fullWidth.test(str);\n  };\n\n  validator.isHalfWidth = function (str) {\n    return halfWidth.test(str);\n  };\n\n  validator.isVariableWidth = function (str) {\n    return fullWidth.test(str) && halfWidth.test(str);\n  };\n\n  validator.isSurrogatePair = function (str) {\n    return surrogatePair.test(str);\n  };\n\n  validator.isBase64 = function (str) {\n    return base64.test(str);\n  };\n\n  validator.isMongoId = function (str) {\n    return validator.isHexadecimal(str) && str.length === 24;\n  };\n\n  validator.ltrim = function (str, chars) {\n    var pattern = chars ? new RegExp('^[' + chars + ']+', 'g') : /^\\s+/g;\n    return str.replace(pattern, '');\n  };\n\n  validator.rtrim = function (str, chars) {\n    var pattern = chars ? new RegExp('[' + chars + ']+$', 'g') : /\\s+$/g;\n    return str.replace(pattern, '');\n  };\n\n  validator.trim = function (str, chars) {\n    var pattern = chars ? new RegExp('^[' + chars + ']+|[' + chars + ']+$', 'g') : /^\\s+|\\s+$/g;\n    return str.replace(pattern, '');\n  };\n\n  validator.escape = function (str) {\n    return str.replace(/&/g, '&amp;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\\//g, '&#x2F;').replace(/\\`/g, '&#96;');\n  };\n\n  validator.stripLow = function (str, keep_new_lines) {\n    var chars = keep_new_lines ? '\\\\x00-\\\\x09\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F' : '\\\\x00-\\\\x1F\\\\x7F';\n    return validator.blacklist(str, chars);\n  };\n\n  validator.whitelist = function (str, chars) {\n    return str.replace(new RegExp('[^' + chars + ']+', 'g'), '');\n  };\n\n  validator.blacklist = function (str, chars) {\n    return str.replace(new RegExp('[' + chars + ']+', 'g'), '');\n  };\n\n  var default_normalize_email_options = {\n    lowercase: true\n  };\n\n  validator.normalizeEmail = function (email, options) {\n    options = merge(options, default_normalize_email_options);\n\n    if (!validator.isEmail(email)) {\n      return false;\n    }\n\n    var parts = email.split('@', 2);\n    parts[1] = parts[1].toLowerCase();\n\n    if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {\n      parts[0] = parts[0].toLowerCase().replace(/\\./g, '');\n\n      if (parts[0][0] === '+') {\n        return false;\n      }\n\n      parts[0] = parts[0].split('+')[0];\n      parts[1] = 'gmail.com';\n    } else if (options.lowercase) {\n      parts[0] = parts[0].toLowerCase();\n    }\n\n    return parts.join('@');\n  };\n\n  function merge(obj, defaults) {\n    obj = obj || {};\n\n    for (var key in defaults) {\n      if (typeof obj[key] === 'undefined') {\n        obj[key] = defaults[key];\n      }\n    }\n\n    return obj;\n  }\n\n  function currencyRegex(options) {\n    var symbol = '(\\\\' + options.symbol.replace(/\\./g, '\\\\.') + ')' + (options.require_symbol ? '' : '?'),\n        negative = '-?',\n        whole_dollar_amount_without_sep = '[1-9]\\\\d*',\n        whole_dollar_amount_with_sep = '[1-9]\\\\d{0,2}(\\\\' + options.thousands_separator + '\\\\d{3})*',\n        valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],\n        whole_dollar_amount = '(' + valid_whole_dollar_amounts.join('|') + ')?',\n        decimal_amount = '(\\\\' + options.decimal_separator + '\\\\d{2})?';\n    var pattern = whole_dollar_amount + decimal_amount; // default is negative sign before symbol, but there are two other options (besides parens)\n\n    if (options.allow_negatives && !options.parens_for_negatives) {\n      if (options.negative_sign_after_digits) {\n        pattern += negative;\n      } else if (options.negative_sign_before_digits) {\n        pattern = negative + pattern;\n      }\n    } // South African Rand, for example, uses R 123 (space) and R-123 (no space)\n\n\n    if (options.allow_negative_sign_placeholder) {\n      pattern = '( (?!\\\\-))?' + pattern;\n    } else if (options.allow_space_after_symbol) {\n      pattern = ' ?' + pattern;\n    } else if (options.allow_space_after_digits) {\n      pattern += '( (?!$))?';\n    }\n\n    if (options.symbol_after_digits) {\n      pattern += symbol;\n    } else {\n      pattern = symbol + pattern;\n    }\n\n    if (options.allow_negatives) {\n      if (options.parens_for_negatives) {\n        pattern = '(\\\\(' + pattern + '\\\\)|' + pattern + ')';\n      } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {\n        pattern = negative + pattern;\n      }\n    }\n\n    return new RegExp('^' + // ensure there's a dollar and/or decimal amount, and that it doesn't start with a space or a negative sign followed by a space\n    '(?!-? )(?=.*\\\\d)' + pattern + '$');\n  }\n\n  validator.init();\n  return validator;\n});","map":null,"metadata":{},"sourceType":"script"}